# 01장 C++의 간단한 소개



## 값 의미론 (P.42)

C++의 일반 객체는 assign operator(=)에 의해 값을 '복사'하여 새로운 메모리에 새로운 객체를 생성한다.

자바 등의 대부분의 상위 수준 언어는 복사가 아닌 참조(혹은 포인터?)를 전달하기 때문에 기존 객체에 대한 소유권만 공유하게 된다.

그래서 C++에서 assign을 할 때 값을 복사할건지 참조를 복사할건지를 구분해서 코드를 작성해야 한다.

값을 복사하면 신경쓸게 없지만 메모리와 속도 비용이 늘어나고 참조를 복사하면 여러 객체에서 같은 주소의 값을 참조하고 있으니 서로간에 미치는 영향을 고려해서 짜야한다.

그래서 C++을 쓸때 값을 넘기거나 함수의 객체 인자를 `const auto&`로 받으라고 권장한다. (나는 `auto&`로 받으면 뭐가 오는지 코드를 읽을수가 없어서 좋아하진 않지만) 각 부분의 의미는 다음과 같다.

- const: 값을 바꾸지 않고 읽기만 한다. 참조를 받더라도 참조된 값을 바꾸지 못하기 때문에 다른 객체에 영향을 주지 않아 안전하다.
- auto: 컴파일러에서 알아서 타입을 정해준다. `int a = 1; auto b = a;` 이면 자동으로 b는 int가 된다.
- `&`: 값이 아닌 참조를 복사한다. 새로운 메모리를 할당하지 않기 때문에 비용이 들지 않는다.



## const 정확성(P.44)

const 키워드는 다양한 문맥에서 값을 바꿀수 있는 권한을 제어한다. 포인터나 참조로 다른 객체를 받으면 같은 주소에 대한 쓰기 권한 생겨서 원하지 않는 값 수정이 생길수 있으므로 const를 이용해 이를 원천적으로 차단한다.

또한 클래스 멤버 함수에 쓰이면 함수가 멤버 변수를 수정할 권한이 있는지도 지정할 수 있다. (P.44 예제)



## 엄격한 클래스 인터페이스 (P.49)

P.50의 예제에서 Boat 클래스가 Engine 클래스 객체를 shared_ptr 형태로 받았기 때문에 이 Engine 객체는 다른데서도 쓰일수 있고 값도 수정될 수 있다. 

Boat끼리 복사를 하면 Boat의 멤버 변수들이 단순히 = operator에 의해 복사가 되는데 여기서 중요한 점은 Engine끼리 복사가 되는게 아니라 shared_ptr\<Engine\> 끼리 복사가 된다는 것이다. 

포인터만 복사가 되므로 두 개의 Boat 객체가 같은 Engine 객체를 참조하여 boat0에서 Engine의 oil_ 값을 바꾸면 boat1에서도 바뀐다.

클래스의 멤버 변수로 포인터나 참조 객체를 가지고 있는 경우에 이렇게 객체의 복사에 유의해야 한다. 이러한 다중 참조 문제를 해결하기 위해서는 어떤건 값을 복사하고 어떤건 참조만 복사할지를 정의할 = operator를 직접 구현하거나 P.51의 예제처럼 복사가 불가능하게 만들수도 있다.

함수 삭제에 대한 자세한 설명은 여기서 볼 수 있다.

<https://docs.microsoft.com/ko-kr/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=vs-2019>







